import { Signer, Contract } from 'ethers';
import { TransactionReceipt } from 'ethers/providers';
import { BigNumber } from 'bignumber.js';
import { Address, Amount, Liability, Counter, SignatureSol, Round } from '../BasicTypes';
import { MediatorMock } from '../../contracts/wrappers/MediatorMock';
import { SummaryParams, Proof, ProofVector } from '../SmartContractTypes';
import { IMediatorAsync } from './IMediatorAsync';
import { Mediator } from '../../contracts/wrappers/Mediator';
export declare const POSDISPUTE1 = 1;
export declare const POSDISPUTE2 = 2;
export declare class MediatorAsync implements IMediatorAsync {
    private contractWithSigner;
    readonly contractAddress: Address;
    constructor(signer: Signer, contract: MediatorMock | Mediator);
    getContractWrapper(): Contract;
    getBalance(): Promise<Amount>;
    commit(root: Liability, tokenAddress: Address): Promise<TransactionReceipt>;
    isApprovalsSummaryValid(approvSummary: SummaryParams, sig: SignatureSol, aliceAddress: Address): Promise<any>;
    initiateWithdrawal(proof: Proof, withdrawalAmount: Amount): Promise<TransactionReceipt>;
    depositsToken(tokenAddress: Address, amount: Amount | number): Promise<TransactionReceipt>;
    getCurrentRound(): Promise<any>;
    getCurrentQuarter(): Promise<any>;
    pendingWithdrawals(round: Round, tokenAddress: Address, clientAddress: Address): Promise<BigNumber>;
    isHalted(): Promise<boolean>;
    cancelWithdrawal(proof: Proof, summary: SummaryParams, sig: SignatureSol): Promise<TransactionReceipt>;
    cancelWithdrawalWithoutSummary(proof: Proof, round: Round): Promise<TransactionReceipt>;
    deposits(round: Round, tokenAddress: Address, clientAddress: Address): Promise<any>;
    totalDeposits(round: Round, tokenAddress: Address): Promise<any>;
    totalDepositsSinceBeginning(tokenAddress: Address): Promise<BigNumber>;
    totalPendingWithdrawals(round: Round, tokenAddress: Address): Promise<BigNumber>;
    totalPendingWithdrawalsSinceBeginning(tokenAddress: Address): Promise<BigNumber>;
    confirmWithdrawal(round: Round, tokenAddress: Address): Promise<TransactionReceipt>;
    totalWithdrawals(round: Round, tokenAddress: Address): Promise<any>;
    totalWithdrawalsSinceBeginning(tokenAddress: Address): Promise<BigNumber>;
    withdrawals(round: Round, tokenAddress: Address, clientAddress: Address): Promise<any>;
    disputes(clientAddress: Address): Promise<any>;
    openBalanceDispute(proofVector: ProofVector, summary: SummaryParams, sig: SignatureSol): Promise<TransactionReceipt>;
    closeBalanceDispute(approvalS: SummaryParams, sigApprovalS: SignatureSol, fillsS: SummaryParams, sigFillsS: SignatureSol, proofVector: ProofVector, clientAddress: Address): Promise<TransactionReceipt>;
    recoverAllFunds(proof: Proof): Promise<TransactionReceipt>;
    recoverOnChain(tokenAddress: Address): Promise<TransactionReceipt>;
    isProofValid(proof: Proof, round: Round): Promise<any>;
    setOpenBalanceDisputeCounter(n: number): Promise<TransactionReceipt>;
    openBalanceDisputeCounter(): Promise<any>;
    closeDispute(clientAddress: Address): Promise<TransactionReceipt>;
    destroyDispute(clientAddress: Address): Promise<TransactionReceipt>;
    setDisputeSummaryCounter(clientAddress: Address, counter: Counter): Promise<TransactionReceipt>;
    setPreviousOpeningBalanceClient(clientAddress: Address, openingBalance: Amount, pos: number): Promise<TransactionReceipt>;
    setTotalWithdrawalAmount(round: Round, tokenAddress: Address, amount: Amount): Promise<TransactionReceipt>;
    openingBalances(round: Round, tokenAddress: Address): Promise<Amount>;
    halt(): Promise<TransactionReceipt>;
}
export declare class TokenAsync {
    private contractWithSigner;
    contractAddress: Address;
    constructor(signer: Signer, contract: Contract);
    balanceOf(address: Address): Promise<BigNumber>;
    allowance(owner: Address, spender: Address): Promise<BigNumber>;
    approve(to: Address, amount: Amount): Promise<TransactionReceipt>;
    withdraw(): Promise<number>;
}
