/* Generated by ts-generator ver. 0.0.8 */
/* tslint:disable */

import { Contract, ContractTransaction, EventFilter } from "ethers";
import { Provider } from "ethers/providers";
import { BigNumber } from "ethers/utils";

export class Mediator extends Contract {
  functions: {
    commitsCounter(arg0: number | string): Promise<BigNumber>;

    totalWithdrawals(arg0: number | string, arg1: string): Promise<BigNumber>;

    deposits(
      arg0: number | string,
      arg1: string,
      arg2: string
    ): Promise<BigNumber>;

    isFillsSummaryValid(
      fillsSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      clientAddress: string,
      sig: (string)[]
    ): Promise<boolean>;

    isApprovalsSummaryValid(
      approvSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      sig: (string)[],
      clientAddress: string
    ): Promise<boolean>;

    totalPendingWithdrawalsSinceBeginning(arg0: string): Promise<BigNumber>;

    pendingWithdrawals(
      arg0: number | string,
      arg1: string,
      arg2: string
    ): Promise<BigNumber>;

    openingBalances(arg0: number | string, arg1: string): Promise<BigNumber>;

    withdrawals(
      arg0: number | string,
      arg1: string,
      arg2: string
    ): Promise<BigNumber>;

    isProofValid(
      proof: {
        clientOpeningBalance: number | string;
        tokenAddress: string;
        clientAddress: string;
        hashes: (string)[];
        sums: (number | string)[];
      },
      round: number | string
    ): Promise<boolean>;

    totalDepositsSinceBeginning(arg0: string): Promise<BigNumber>;

    commits(arg0: number | string, arg1: string): Promise<string>;

    recovered(arg0: string, arg1: string): Promise<boolean>;

    totalPendingWithdrawals(
      arg0: number | string,
      arg1: string
    ): Promise<BigNumber>;

    disputes(
      arg0: string
    ): Promise<{
      openingBalance1: BigNumber;
      openingBalance2: BigNumber;
      round: BigNumber;
      summary: object[];
      open: boolean;
      0: BigNumber;
      1: BigNumber;
      2: BigNumber;
      3: object[];
      4: boolean;
    }>;

    totalWithdrawalsSinceBeginning(arg0: string): Promise<BigNumber>;

    isMerkleProofValid(
      hashes: (string)[],
      sums: (number | string)[],
      root: string,
      leaf: string,
      sum: number | string
    ): Promise<boolean>;

    tokenRegistry(arg0: string): Promise<boolean>;

    totalDeposits(arg0: number | string, arg1: string): Promise<BigNumber>;

    closeBalanceDispute(
      approvSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      sigApprov: (string)[],
      fillsSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      sigFillsSummary: (string)[],
      proofVectorPreviousRound: {
        proof1: {
          clientOpeningBalance: number | string;
          tokenAddress: string;
          clientAddress: string;
          hashes: (string)[];
          sums: (number | string)[];
        };
        proof2: {
          clientOpeningBalance: number | string;
          tokenAddress: string;
          clientAddress: string;
          hashes: (string)[];
          sums: (number | string)[];
        };
      },
      clientAddress: string
    ): Promise<ContractTransaction>;

    updateHaltedState(): Promise<ContractTransaction>;

    commit(
      root: string,
      tokenAddress: string,
      claimedOpeningBalance: number | string
    ): Promise<ContractTransaction>;

    initiateWithdrawal(
      proof: {
        clientOpeningBalance: number | string;
        tokenAddress: string;
        clientAddress: string;
        hashes: (string)[];
        sums: (number | string)[];
      },
      withdrawalAmount: number | string
    ): Promise<ContractTransaction>;

    depositTokens(
      tokenAddress: string,
      amount: number | string
    ): Promise<ContractTransaction>;

    recoverOnChain(tokenAddress: string): Promise<ContractTransaction>;

    recoverAllFunds(proof: {
      clientOpeningBalance: number | string;
      tokenAddress: string;
      clientAddress: string;
      hashes: (string)[];
      sums: (number | string)[];
    }): Promise<ContractTransaction>;

    cancelWithdrawalWithoutSummary(
      proof: {
        clientOpeningBalance: number | string;
        tokenAddress: string;
        clientAddress: string;
        hashes: (string)[];
        sums: (number | string)[];
      },
      round: number | string
    ): Promise<ContractTransaction>;

    cancelWithdrawal(
      proof: {
        clientOpeningBalance: number | string;
        tokenAddress: string;
        clientAddress: string;
        hashes: (string)[];
        sums: (number | string)[];
      },
      approvSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      sig: (string)[]
    ): Promise<ContractTransaction>;

    confirmWithdrawal(
      round: number | string,
      tokenAddress: string
    ): Promise<ContractTransaction>;

    openBalanceDispute(
      proofVector: {
        proof1: {
          clientOpeningBalance: number | string;
          tokenAddress: string;
          clientAddress: string;
          hashes: (string)[];
          sums: (number | string)[];
        };
        proof2: {
          clientOpeningBalance: number | string;
          tokenAddress: string;
          clientAddress: string;
          hashes: (string)[];
          sums: (number | string)[];
        };
      },
      fillsSummary: {
        round: number | string;
        counter: number | string;
        lot1: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
        lot2: {
          amountSign: boolean;
          amount: number | string;
          tokenAddress: string;
        };
      },
      sigFillsSummary: (string)[]
    ): Promise<ContractTransaction>;

    operatorAddress(): Promise<string>;
    quarterSize(): Promise<BigNumber>;
    roundSize(): Promise<BigNumber>;
    getCurrentQuarter(): Promise<BigNumber>;
    getCurrentBlockNumber(): Promise<BigNumber>;
    blockNumberAtCreation(): Promise<BigNumber>;
    numTokens(): Promise<BigNumber>;
    getCurrentRound(): Promise<BigNumber>;
    openBalanceDisputeCounter(): Promise<BigNumber>;
    halted(): Promise<boolean>;
    isHalted(): Promise<boolean>;
  };
  filters: {
    Deposit(
      round: null,
      tokenAddress: null,
      clientAddress: null,
      amount: null
    ): EventFilter;

    InitWithdrawal(
      round: null,
      tokenAddress: null,
      clientAddress: null,
      amount: null
    ): EventFilter;

    ConfirmWithdrawal(
      round: null,
      tokenAddress: null,
      clientAddress: null,
      amount: null
    ): EventFilter;
  };
}
