import { TransactionReceipt } from 'ethers/providers';
import { Contract } from 'ethers';
import { Address, Amount, Liability, Counter, SignatureSol, Quarter, Round } from '../BasicTypes';
import { SummaryParams, Proof, Dispute, ProofVector } from '../SmartContractTypes';
export interface IMediatorAsync {
    readonly contractAddress: Address;
    getContractWrapper(): Contract;
    getBalance(): Promise<Amount>;
    commit(root: Liability, tokenAddress: Address): Promise<TransactionReceipt>;
    isApprovalsSummaryValid(approvSummary: SummaryParams, sig: SignatureSol, aliceAddress: Address): Promise<boolean>;
    initiateWithdrawal(proof: Proof, withdrawalAmount: Amount): Promise<TransactionReceipt>;
    depositsToken(tokenAddress: Address, amount: Amount | number): Promise<TransactionReceipt>;
    getCurrentRound(): Promise<Round>;
    getCurrentQuarter(): Promise<Quarter>;
    pendingWithdrawals(round: Round, tokenAddress: Address, clientAddress: Address): Promise<Amount>;
    isHalted(): Promise<boolean>;
    cancelWithdrawal(proof: Proof, summary: SummaryParams, sig: SignatureSol): Promise<TransactionReceipt>;
    cancelWithdrawalWithoutSummary(proof: Proof, round: Round): Promise<TransactionReceipt>;
    deposits(round: Round, tokenAddress: Address, clientAddress: Address): Promise<Amount>;
    totalDeposits(round: Round, tokenAddress: Address): Promise<Amount>;
    totalDepositsSinceBeginning(tokenAddress: Address): Promise<Amount>;
    totalPendingWithdrawals(round: Round, tokenAddress: Address): Promise<Amount>;
    totalPendingWithdrawalsSinceBeginning(tokenAddress: Address): Promise<Amount>;
    confirmWithdrawal(round: Round, tokenAddress: Address): Promise<TransactionReceipt>;
    totalWithdrawals(round: Round, tokenAddress: Address): Promise<Amount>;
    totalWithdrawalsSinceBeginning(tokenAddress: Address): Promise<Amount>;
    withdrawals(round: Round, tokenAddress: Address, clientAddress: Address): Promise<Amount>;
    disputes(tokenAddress: Address, clientAddress: Address): Promise<Dispute>;
    openBalanceDispute(proofVector: ProofVector, summary: SummaryParams, sig: SignatureSol): Promise<TransactionReceipt>;
    closeBalanceDispute(approvalS: SummaryParams, sigApprovalS: SignatureSol, fillsS: SummaryParams, sigFillsS: SignatureSol, proofVector: ProofVector, clientAddress: Address): Promise<TransactionReceipt>;
    recoverAllFunds(proof: Proof): Promise<TransactionReceipt>;
    recoverOnChain(tokenAddress: Address): Promise<TransactionReceipt>;
    isProofValid(proof: Proof, round: Round): Promise<boolean>;
    setOpenBalanceDisputeCounter(n: number): Promise<TransactionReceipt>;
    openBalanceDisputeCounter(): Promise<TransactionReceipt>;
    closeDispute(clientAddress: Address): Promise<TransactionReceipt>;
    destroyDispute(clientAddress: Address): Promise<TransactionReceipt>;
    setDisputeSummaryCounter(clientAddress: Address, counter: Counter): Promise<TransactionReceipt>;
    setPreviousOpeningBalanceClient(clientAddress: Address, openingBalance: Amount, pos: number): Promise<TransactionReceipt>;
    setTotalWithdrawalAmount(round: Round, tokenAddress: Address, amount: Amount): Promise<TransactionReceipt>;
    openingBalances(round: Round, tokenAddress: Address): Promise<Amount>;
    halt(): Promise<TransactionReceipt>;
    roundSize(): Promise<Amount>;
}
